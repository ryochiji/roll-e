"""
This script implements a rudimentary (but potentially useful/effective in some
artificially constrained circumstances) shape-matching algorithm. It can 
match similar shapes regardless of scale, but will not handle rotations. 
This algorithm is currently optimized for basic geometric shapes with mostly
straight lines, though (I think) it could be adapted for slightly more complex
shapes. It most likely will not find a tank in the forest.
"""
import sys
from SimpleCV import Image, Color, DrawingLayer
import math
import time

global M
M = [ 5 for i in range(0,512) ]  # initialize with '5', which means there 
                                 # are pixels of unknown pattern

M[0] = 0   # 0 means there are no pixels/edges

# Horizontal line
M[7] = 1 
M[56] = 1 
M[64+128+256] = 1 
M[8+16] = 1
M[16+32] = 1

# Vertical line
M[1+8+64] = 2 
M[2+16+128] = 2 
M[2+16] = 2
M[16+128] = 2
M[292] = 2 

# Top left to bottom right
M[1+16+256] = 3 
M[1+16] = 3
M[16+256] = 3
M[2+32] = 3 
M[8+128] = 3 

M[1+2+16+128+256] = 3
M[1+2+32] = 3
M[8+16+256] = 3
M[1+16+128] = 3
M[1+32+256] = 3
M[2+32+256] = 3
M[2+16+256] = 3
M[1+8+128] = 3

# Top right to bottom left
M[4+16+64] = 4 
M[4+16] = 4
M[16+64] = 4
M[2+8] = 4 
M[32+128] = 4 

M[4+2+8] = 4
M[32+16+64] = 4
M[2+8+64] = 4
M[4+8+64] = 4
M[4+16+128] = 4
M[4+32+128] = 4
M[2+16+64] = 4

def get_bitmap(img, x_offset, y_offset):
    """ Take a 3x3 area of pixels and turn it into 9-bit binary """
    out = 0
    for y in range(0,3):
        for x in range(0,3):
            p = img.getPixel(x+x_offset, y+y_offset)
            if not p: continue
            if not p[0]>250.0: continue
            out |=  1 << ( (y*3) + x )
    return out

def draw_bitmap(dl, pattern, x, y):
    if pattern==1:
        dl.line((x, y+1), (x+2, y+1), color=Color.RED, antialias=False)
    elif pattern==2:
        dl.line((x+1, y), (x+1, y+2), color=Color.RED, antialias=False)
    elif pattern==3:
        dl.line((x,y), (x+2, y+2), color=Color.RED, antialias=False)
    elif pattern==4:
        dl.line((x+2,y), (x, y+2), color=Color.RED, antialias=False)

def match_patterns(img, dl=None):
    """ Take an Image containing edges (and only edges!) and create a 2D 
        array of "patterns". There are 6 patterns that this algorithm knows of: 
            0 = no lines/edges
            1 = horizontal line
            2 = vertical line
            3 = diagonal (top-left to bottom-right)
            4 = diagonal (top-right to bottom-left)
            5 = undiscernable pixel pattern
        This data will generally be encapsulated by the PatternMatrix class.
    """
    data = []
    for y in range(0, img.height-3, 3):
        row = []
        for x in range(0, img.width-3, 3):
            bm = get_bitmap(img, x, y)
            pattern = M[bm]
            if dl: draw_bitmap(dl, pattern, x, y)
            row.append(pattern)
        data.append(row)
    return data 


class PatternMatrix:
    """ See description above. """

    def __init__(self, img, data=None):
        self.img = img
        if not data:
            data = match_patterns(img)
        self.data = data
        self.height = len(data)
        self.width = len(data[0]) if self.height else 0

    def __str__(self):
        out = []
        for row in self.data:
            out.append("\t".join(map(str,row)))
        return "\n".join(out)

    def get(self, x, y):
        return self.data[y][x]


    def pattern_vector(self, region):
        """ Calculate pattern vector for a given region. A pattern vector is
            a vector that represents the relative proportion of patterns 
            represented in that region.
            e.g. A region that is mostly a vertical line will have a high value
                 for vector[2].
        """
        x1 = int(region[0] * float(self.width))
        x2 = int(region[2] * float(self.width))
        y1 = int(region[1] * float(self.height))
        y2 = int(region[3] * float(self.height))

        print "%s,%s %s,%s" % (x1,y1, x2, y2)
        vector = [0] * 6 
        for x in range(x1, x2):
            for y in range(y1, y2):
                pattern = self.get(x,y)
                vector[pattern] += 1
        vector[0] = 0
        print "vector: %s" % (vector)
        total = sum(vector)
        if total:
            # normalize
            vector = [ float(n)/float(total) for n in vector ]
        return vector 


    def get_fingerprint_regions(self):
        """ Return data-structure that defines regions. """ 
        return [
            [ 0.0, 0.0, 0.5, 1.0],
            [ 0.5, 0.0, 1.0, 1.0],
            [ 0.0, 0.0, 1.0, 0.5],
            [ 0.0, 0.5, 1.0, 1.0],
            [ 0.0, 0.0, 0.5, 0.5],
            [ 0.5, 0.0, 1.0, 0.5],
            [ 0.0, 0.5, 0.5, 1.0],
            [ 0.5, 0.5, 1.0, 1.0]
            ]


    def fingerprint(self, regions=None):
        """ Create a 'fingerprint' that represents this pattern matrix.
            A fingerprint is generated by breaking the matrix into overlapping
            regions, and calculating pattern vectors for each region.
        """
        if not regions:
            regions = self.get_fingerprint_regions()
        print "Matrix dimensions %s,%s" % (self.width, self.height) 
        out = []
        for region in regions:
            vector = self.pattern_vector(region)
            out.append((region, vector))
        return out

    def cosine_similarity(self, vec1, vec2):
        """ Cosine similairty. Input vectors should be lists. """

        if len(vec1) != len(vec2):
            raise Exception("Mismatched vector lengths")

        numerator = sum([vec1[x] * vec2[x] for x in range(0,len(vec1))])

        sum1 = sum([x**2 for x in vec1])
        sum2 = sum([x**2 for x in vec2])
        denominator = math.sqrt(sum1) * math.sqrt(sum2)

        if not denominator:
            return 0.0
        else:
            return float(numerator) / denominator


    def similarity(self, matrix):
        """ Calculate similarity between this pattern matrix and another
            matrix. This calculates the cosine distance between pattern
            vectors for all the regions. Similar shapes should have similar
            vector patterns in all regions.
        """ 
        my_print = self.fingerprint()
        their_print = matrix.fingerprint(regions=self.get_fingerprint_regions())
        if len(my_print) != len(their_print):
            raise Exception("Finger print lengths don't match")

        out = []
        for i in range(0, len(my_print)):
            out.append(self.cosine_similarity(my_print[i][1], 
                                              their_print[i][1])) 

        print "Similarity: %s" % (repr(out))
        return sum(out) / float(len(out))


if __name__=="__main__":
    img = Image(sys.argv[-1])
    dl = DrawingLayer((img.width,img.height))
    img.addDrawingLayer(dl)
    patterns = match_patterns(img, dl)
    img.save('outline2.png')
    for row in patterns:
        print "\t".join(row)
